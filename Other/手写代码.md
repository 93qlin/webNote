<h4>实现练手相关</h4>

&emsp;[1. 函数节流](#h1)

&emsp;[2. 函数防抖](#h2)

&emsp;[3. 手写promise](#h3)


<h4>算法相关</h4>

&emsp;[1. JS实现的数组全排列输出算法](#S1)

&emsp;[2. 判断一个单词是否是回文？](#S2)

&emsp;[3. 去掉一组整型数组重复的值](#S3)

&emsp;[4. 随机生成指定长度的字符串](#S4)

&emsp;[5. js中的广度优先遍历（BFS）和深度优先遍历（DFS）][https://www.jianshu.com/p/b4d8085e84bd][https://www.jianshu.com/p/5e9ea25a1aae](#S4)



<h4>其他</h4>

<h5 id='h1'>1. 函数节流</h5>
```
function throttle(func,interval){
        let timeout;
        let startTime = new Date();
        interval || (interval = 250)

        return function (){
            clearTimeout(timeout);
            let curTime = new Date();
            if(curTime - startTime <= interval){
                //小于规定时间间隔时，用setTimeout在指定时间后再执行
                timeout = setTimeout(()=>{
                    func();
                },interval)
            } else {
                //重新计时并执行函数
                startTime = curTime;
                func()
            }
        }
    }

function throttle(fn, threshold){
    var last

    var timer

    threshold || (threshold = 250)

    return function(...args){
        let context = this
        let args = arguments

        var now = +new Date()

        if(last&&now<last+threshold){
            clearTimeout(timer)

            timer = setTimeout(function(){
                last = now
                fn.apply(context, args)
            },threshold)
        }else {
            last = now
            fn.apply(context, args)
        }
    }
}

function throttle(fn,delay){
    let timer = null;
    let startTime = +new Date()

    return function(...args){
        let curTime = Date .now()
        let remaining = delay - (curTime -startTime)
        const context = this
        clearTimeout(timer)
        if(remaining<=0){
            fn.apply(context,args)
            startTime = +new Date();
        }else{
            timer = setTimeout(fn,remaining)
        }
    }
}
```
<h5 id='h2'>2. 函数防抖</h5>
```
export function debounce(func, delay) {
    let timer
    return (...args) => {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            func.apply(this, args)
        }, delay)
    }
}
```
<h5 id='h3'>3. 手写promise</h5>
简化版
```
//简易promise实现(resolve,reject)
function promise(fn) {
    this.value = undefined // 成功状态值
    this.err = undefined // 失败状态值
    this.status = 'pending' // 开始状态（就绪）
    var t = this
    // 就绪 -> 成功
    function resolve(val) {
        if (t.status === 'pending') {
            t.value = val
            t.status = 'success'
        }
    }
    // 就绪 -> 失败
    function reject(err) {
        if (t.status === 'pending') {
            t.err = err
            t.status = 'fail'
        }
    }
    fn(resolve, reject)
}
promise.prototype.then = function(isSuccess, isFail) {
    var t = this
    // 实现promise的链式调用
    return new promise(function(resolve, reject) {
        // 用setTimeout模拟实现then方法的异步操作
        setTimeout(function() {
            if (t.status === 'success') {
                // 将then1回调函数返回的值传给then2回调函数，以此类推
                resolve(isSuccess(t.value))
            }
            if (t.status === 'fail') {
                reject(isFail(t.err))
            }
        })
    })

}

// test
var p = new promise(function(resolve, reject) {
    if (1) {
        resolve("test resolve success")
    } else {
        reject("test rejecr fail")
    }

})
p.then(function(val) {
    console.log(val)
    return val + "链式调用return"
}).then(function(val) {
    console.log(val)
})

// test resolve success
// test resolve success链式调用return
```
<h5 id='S1'>1. JS实现的数组全排列输出算法</h5>
> 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。
```
function permute(input) {
  var permArr = [],
  usedChars = [];
  function main(input){
    var i, ch;
    for (i = 0; i < input.length; i++) {
      ch = input.splice(i, 1)[0];
      usedChars.push(ch);
      if (input.length == 0) {
        permArr.push(usedChars.slice());
      }
      main(input);
      input.splice(i, 0, ch);
      usedChars.pop();
    }
    return permArr
  }
  return main(input);
};
console.log(permute([5, 3, 7, 1]));
```
<h5 id='S2'>2. 判断一个单词是否是回文？</h5>
```
function checkPalindrom(str) {  
    return str == str.split('').reverse().join('');
}
```
<h5 id='S3'>3. 去掉一组整型数组重复的值</h5>
比如 输入: [1,13,24,11,11,14,1,2]，  输出: [1,13,24,11,14,2] ，需要去掉重复的11 和 1 这两个元素。
```
function(arr) {  
  let hashTable = {};
  let data = [];
  for(let i=0,l=arr.length;i<l;i++) {
    if(!hashTable[arr[i]]) {
      hashTable[arr[i]] = true;
      data.push(arr[i]);
    }
  }
  return data

}
```
<h5 id='S4'>4. 随机生成指定长度的字符串</h5>
实现一个算法，随机生成指制定长度的字符窜。
```
function randomString(n) {  
  let str = 'abcdefghijklmnopqrstuvwxyz9876543210';
  let tmp = '',
      i = 0,
      l = str.length;
  for (i = 0; i < n; i++) {
    tmp += str.charAt(Math.floor(Math.random() * l));
  }
  return tmp;
}
```
